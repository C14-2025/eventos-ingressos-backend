name: CI/CD Pipeline

on: [push]

env:
  API_URL: ${{ secrets.API_URL }}
  EMAIL: ${{ secrets.EMAIL }}
  PASSWORD: ${{ secrets.PASSWORD }}
  RECIPIENT_EMAIL: ${{ secrets.RECIPIENT_EMAIL }}
  MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
  MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
  REDIS_HOST: ${{ secrets.REDIS_HOST }}
  MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
  MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
  MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
  MYSQL_USER: ${{ secrets.MYSQL_USER }}
  NODE_ENV: ${{ secrets.NODE_ENV }}
  PORT: ${{ secrets.PORT }}
  REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
  REDIS_PORT: ${{ secrets.REDIS_PORT }}
  REDIS_PREFIX: ${{ secrets.REDIS_PREFIX }}

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout do repositório
      uses: actions/checkout@v4

    - name: Adicionar IP do GitHub ao arquivo de hosts
      run: echo "$IP_DO_GITHUB github.com" | sudo tee -a /etc/hosts
      env:
        IP_DO_GITHUB: 20.201.28.151

    - name: Criar arquivo .env
      run: |
        echo "PORT=${{ secrets.PORT }}" > .env
        echo "MYSQL_HOST=${{ secrets.MYSQL_HOST }}" >> .env
        echo "API_URL=${{ secrets.API_URL }}" >> .env
        echo "EMAIL=${{ secrets.EMAIL }}" >> .env
        echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env
        echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
        echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> .env
        echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
        echo "MYSQL_PORT=${{ secrets.MYSQL_PORT }}" >> .env
        echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" >> .env
        echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
        echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> .env
        echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> .env
        echo "REDIS_PREFIX=${{ secrets.REDIS_PREFIX }}" >> .env

    - name: Instalar dependências
      run: npm install

    - name: Subir containers Docker (MySQL / Redis)
      run: docker compose up -d

    - name: Gerar chaves RSA
      run: npx ts-node -r tsconfig-paths/register src/shared/scripts/generateKeys.ts

    - name: Iniciar API e aguardar disponibilidade
      run: |
        echo "Iniciando API..."
        yarn dev &
        echo "Aguardando API responder na porta ${{ secrets.PORT }}..."
        for i in {1..10}; do
          if curl -s http://localhost:${{ secrets.PORT }}/login > /dev/null; then
            echo "API está respondendo!"
            break
          fi
          echo "Tentativa $i: aguardando..."
          sleep 5
        done
        echo "API iniciada para testes."

    - name: Testar Login e JWT
      run: |
        echo "Testando endpoint /login..."
        RESPONSE=$(curl -s -X POST http://localhost:${{ secrets.PORT }}/login \
          -H "Content-Type: application/json" \
          -d '{"email":"${{ secrets.EMAIL }}","password":"${{ secrets.PASSWORD }}"}')

        echo "Resposta recebida:"
        echo "$RESPONSE"

        TOKEN=$(echo "$RESPONSE" | grep -o '"jwt_token":"[^"]*"' | cut -d'"' -f4)

        if [ -z "$TOKEN" ]; then
          echo "Falha no login — jwt_token não encontrado!"
          exit 1
        fi

        echo "Login bem-sucedido. Token extraído:"
        echo "$TOKEN"

        echo "Testando endpoint /me..."
        ME_RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer $TOKEN" http://localhost:${{ secrets.PORT }}/me)
        BODY=$(echo "$ME_RESPONSE" | head -n1)
        STATUS=$(echo "$ME_RESPONSE" | tail -n1)

        echo "Código HTTP: $STATUS"
        echo "Resposta /me:"
        echo "$BODY"

        if [ "$STATUS" -eq 200 ]; then
          echo "Teste de autenticação /me bem-sucedido!"
        else
          echo "Falha na autenticação (HTTP $STATUS)"
          exit 1
        fi

    - name: Rodar testes automatizados
      run: |
        sleep 5
        yarn test --testPathPattern=Service.spec.ts

    - name: Finalizar containers
      if: always()
      run: docker compose down
